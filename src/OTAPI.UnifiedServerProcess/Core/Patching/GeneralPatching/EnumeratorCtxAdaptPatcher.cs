using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Rocks;
using Mono.Collections.Generic;
using MonoMod.Utils;
using OTAPI.UnifiedServerProcess.Commons;
using OTAPI.UnifiedServerProcess.Core.Analysis.MethodCallAnalysis;
using OTAPI.UnifiedServerProcess.Core.FunctionalFeatures;
using OTAPI.UnifiedServerProcess.Core.Patching.DataModels;
using OTAPI.UnifiedServerProcess.Core.Patching.GeneralPatching.Arguments;
using OTAPI.UnifiedServerProcess.Extensions;
using OTAPI.UnifiedServerProcess.Loggers;
using System;
using System.Collections.Generic;
using System.Linq;

namespace OTAPI.UnifiedServerProcess.Core.Patching.GeneralPatching
{
    /// <summary>
    /// Handle the contextualization of the iterator generated by yield return
    /// </summary>
    /// <param name="logger"></param>
    /// <param name="methodCallGraph"></param>
    public sealed class EnumeratorCtxAdaptPatcher(ILogger logger, MethodCallGraph methodCallGraph) : GeneralPatcher(logger), IContextInjectFeature, IMethodCheckCacheFeature
    {
        public sealed override string Name => nameof(EnumeratorCtxAdaptPatcher);
        public MethodCallGraph MethodCallGraph => methodCallGraph;

        public sealed override void Patch(PatcherArguments arguments) {
            ModuleDefinition module = arguments.MainModule;
            ContextBoundMethodMap mappedMethod = arguments.LoadVariable<ContextBoundMethodMap>();

            Dictionary<string, MethodDefinition> addedParamMethods = [];

            foreach (TypeDefinition? type in module.GetAllTypes().ToArray()) {

                foreach (MethodDefinition? method in type.Methods.ToArray()) {
                    if (!method.HasBody) {
                        continue;
                    }
                    var methodId = method.GetIdentifier();
                    // Only context bound methods could process,
                    if (mappedMethod.originalToContextBound.ContainsKey(methodId)) {
                        // And only reused singleton methods could be context bound at same time existing in the original method map
                        if (!arguments.ContextTypes.TryGetValue(type.FullName, out ContextTypeData? singletonType)
                            || !singletonType.IsReusedSingleton
                            || !singletonType.ReusedSingletonMethods.ContainsKey(methodId)) {
                            continue;
                        }
                    }
                    ProcessMethod(arguments, mappedMethod, method);
                }
            }
        }

        void ProcessMethod(PatcherArguments arguments,
            ContextBoundMethodMap mappedMethod,
            MethodDefinition caller) {

            Dictionary<string, (TypeReference enumeratorRef, FieldReference contextFieldRef)> processedEnumerator = [];
            foreach (Instruction? instruction in caller.Body.Instructions.ToArray()) {
                if (instruction.OpCode != OpCodes.Newobj) {
                    continue;
                }
                var ctor = (MethodReference)instruction.Operand;
                if (!ctor.DeclaringType.Name.OrdinalStartsWith('<')) {
                    continue;
                }
                TypeDefinition? enumeratorDef = ctor.DeclaringType.Resolve();
                if (enumeratorDef is null) {
                    continue;
                }
                if (!enumeratorDef.Interfaces.Any(x => x.InterfaceType.FullName == "System.Collections.IEnumerator")) {
                    continue;
                }
                bool anyContextUsed = false;
                foreach (MethodDefinition? method in enumeratorDef.Methods) {
                    if (method.IsConstructor) {
                        continue;
                    }
                    if (this.CheckUsedContextBoundField(arguments.InstanceConvdFieldOrgiMap, method)) {
                        anyContextUsed = true;
                        break;
                    }
                }
                if (!anyContextUsed) {
                    continue;
                }

                if (caller.DeclaringType.FullName == ctor.DeclaringType.FullName && caller.Name.OrdinalEndsWith(".GetEnumerator")) {
                    continue; // Skip the create method inside the GetEnumerator itself
                }

                if (caller.DeclaringType.FullName != enumeratorDef.DeclaringType.FullName) {
                    var option = new MonoModCommon.Structure.MapOption(true, typeReplace: new() { { enumeratorDef.DeclaringType, caller.DeclaringType } });
                    TypeDefinition oldEnumeratorDef = enumeratorDef;
                    enumeratorDef = MonoModCommon.Structure.MemberClonedType(enumeratorDef, enumeratorDef.Name, option.IgnoreMethodParameter, option.TypeReplaceMap);

                    static IEnumerable<(TypeDefinition otype, TypeDefinition ntype)> GetTypeReplacePairs(TypeDefinition oldTypeDef, TypeDefinition newTypeDef) {
                        yield return (oldTypeDef, newTypeDef);
                        foreach (TypeDefinition? newNestedType in newTypeDef.NestedTypes) {
                            TypeDefinition oldNestedType = oldTypeDef.NestedTypes.Single(ont => ont.Name == newNestedType.Name);
                            foreach ((TypeDefinition otype, TypeDefinition ntype) pair in GetTypeReplacePairs(oldNestedType, newNestedType)) {
                                yield return pair;
                            }
                        }
                    }
                    foreach ((TypeDefinition? otype, TypeDefinition? ntype) in GetTypeReplacePairs(oldEnumeratorDef, enumeratorDef)) {
                        foreach (MethodDefinition? method in ntype.Methods) {
                            if (method.IsConstructor) {
                                continue;
                            }
                            MethodDefinition omethod = otype.Methods.Single(m => m.GetIdentifier(withDeclaring: false) == method.GetIdentifier(withDeclaring: false));
                            mappedMethod.contextBoundMethods.Add(method.GetIdentifier(), method);
                            mappedMethod.originalToContextBound.Add(omethod.GetIdentifier(), method);
                        }
                    }

                    foreach (Instruction? redirectInst in caller.Body.Instructions) {
                        if (redirectInst.Operand is TypeReference typeRef) {
                            redirectInst.Operand = MonoModCommon.Structure.DeepMapTypeReference(typeRef, option);
                        }
                        else if (redirectInst.Operand is MethodReference methodRef) {
                            redirectInst.Operand = MonoModCommon.Structure.DeepMapMethodReference(methodRef, option);
                        }
                        else if (redirectInst.Operand is FieldReference fieldRef) {
                            FieldDefinition? fieldDef = fieldRef.Resolve();
                            if (fieldDef is null) {
                                continue;
                            }
                            TypeReference declaringType = fieldRef.DeclaringType;
                            if (option.TypeReplaceMap.TryGetValue(declaringType.Resolve(), out TypeDefinition? mappedDeclaringType)
                                && mappedDeclaringType.Fields.Any(f => f.Name == fieldDef.Name && f.IsStatic == fieldDef.IsStatic)) {
                                declaringType = MonoModCommon.Structure.DeepMapTypeReference(fieldRef.DeclaringType, option);
                            }
                            redirectInst.Operand = new FieldReference(fieldRef.Name,
                                MonoModCommon.Structure.DeepMapTypeReference(fieldRef.FieldType, option),
                                declaringType);
                        }
                    }
                }

                FieldDefinition contextFieldDef;
                ParameterDefinition captureParameter;

                if (arguments.ContextTypes.TryGetValue(caller.DeclaringType.FullName, out ContextTypeData? contextBoundType)) {
                    contextFieldDef = new FieldDefinition("<>4__this", FieldAttributes.Public, contextBoundType.ContextTypeDef);
                    enumeratorDef.Fields.Add(contextFieldDef);
                    captureParameter = caller.Body.ThisParameter;
                }
                else if (caller.Parameters[0].ParameterType.FullName == arguments.RootContextDef.FullName) {
                    contextFieldDef = new FieldDefinition(caller.Parameters[0].Name, FieldAttributes.Public, arguments.RootContextDef);
                    enumeratorDef.Fields.Add(contextFieldDef);
                    captureParameter = caller.Parameters[0];
                }
                else {
                    throw new Exception($"Unexpected caller {caller.GetDebugName()} without context bound");
                }

                TypeReference enumeratorRef;
                FieldReference contextFieldRef;
                if (!processedEnumerator.TryGetValue(enumeratorDef.FullName, out (TypeReference enumeratorRef, FieldReference contextFieldRef) enumeratorInfo)) {
                    enumeratorRef = enumeratorDef;
                    contextFieldRef = contextFieldDef;
                    if (enumeratorDef.DeclaringType.HasGenericParameters) {
                        var enumeratorGenericRef = new GenericInstanceType(enumeratorDef);
                        foreach (GenericParameter? genericParam in enumeratorDef.DeclaringType.GenericParameters) {
                            enumeratorGenericRef.GenericArguments.Add(genericParam);
                        }
                        enumeratorRef = enumeratorGenericRef;
                        contextFieldRef = new FieldReference(contextFieldDef.Name, contextFieldDef.FieldType, enumeratorRef);
                    }
                    enumeratorInfo = (enumeratorRef, contextFieldRef);
                }
                else {
                    enumeratorRef = enumeratorInfo.enumeratorRef;
                    contextFieldRef = enumeratorInfo.contextFieldRef;
                }

                Instruction afterCreateEnumerator = caller.Body.Instructions.Single(
                    x =>
                    x.OpCode == OpCodes.Newobj && ((MethodReference)x.Operand).DeclaringType.TryResolve()?.FullName == enumeratorDef.FullName)
                    .Next;
                ILProcessor ilProcessor = caller.Body.GetILProcessor();
                ilProcessor.InsertBeforeSeamlessly(ref afterCreateEnumerator, [
                    Instruction.Create(OpCodes.Dup),
                    MonoModCommon.IL.BuildParameterLoad(caller, caller.Body, captureParameter),
                    Instruction.Create(OpCodes.Stfld, contextFieldRef)
                ]);

                ProcessEnumeratorMethod(arguments, mappedMethod, enumeratorDef, contextFieldDef, caller);

                foreach (MethodDefinition? enumerMethod in enumeratorDef.Methods) {
                    if (!enumerMethod.Name.OrdinalEndsWith(".GetEnumerator") || !enumerMethod.HasBody) {
                        continue;
                    }
                    Collection<Instruction> body = enumerMethod.Body.Instructions;
                    Instruction? createSelf = body.FirstOrDefault(
                        x =>
                        x is Instruction { OpCode.Code: Code.Newobj, Operand: MethodReference mr } &&
                        mr.DeclaringType.FullName == enumeratorDef.FullName);
                    if (createSelf is null) {
                        continue;
                    }
                    if (!MonoModCommon.IL.TryGetReferencedVariable(enumerMethod, createSelf.Next, out VariableDefinition? local)) {
                        throw new Exception($"Failed to get created enumerator variable in {enumerMethod.GetDebugName()}");
                    }
                    body.InsertRange(
                        body.IndexOf(createSelf) + 2,
                        [
                            MonoModCommon.IL.BuildVariableLoad(enumerMethod, enumerMethod.Body, local),
                            Instruction.Create(OpCodes.Ldarg_0),
                            Instruction.Create(OpCodes.Ldfld, contextFieldRef),
                            Instruction.Create(OpCodes.Stfld, contextFieldRef),
                        ]
                    );
                }
            }
        }

        private void ProcessEnumeratorMethod(
            PatcherArguments arguments,
            ContextBoundMethodMap mappedMethods,
            TypeDefinition enumeratorDef,
            FieldDefinition contextFieldDef,
            MethodDefinition caller) {

            TypeReference selfEnumeratorRef = enumeratorDef;
            FieldReference selfContextFieldRef = contextFieldDef;
            if (enumeratorDef.HasGenericParameters) {
                var selfEnumeratorGenericRef = new GenericInstanceType(enumeratorDef);
                foreach (GenericParameter? genericParam in enumeratorDef.GenericParameters) {
                    selfEnumeratorGenericRef.GenericArguments.Add(genericParam);
                }
                selfEnumeratorRef = selfEnumeratorGenericRef;
                selfContextFieldRef = new FieldReference(contextFieldDef.Name, contextFieldDef.FieldType, selfEnumeratorRef);
            }

            foreach (MethodDefinition? enumeratorMethod in enumeratorDef.Methods) {
                if (enumeratorMethod.IsConstructor) {
                    continue;
                }
                foreach (Instruction? inst in enumeratorMethod.Body.Instructions.ToArray()) {
                    switch (inst.OpCode.Code) {
                        case Code.Ldsfld:
                            HandleLoadStaticField(inst, enumeratorMethod, false, arguments, contextFieldDef, selfContextFieldRef);
                            break;
                        case Code.Ldsflda:
                            HandleLoadStaticField(inst, enumeratorMethod, true, arguments, contextFieldDef, selfContextFieldRef);
                            break;
                        case Code.Stsfld:
                            HandleStoreStaticField(inst, enumeratorMethod, arguments, contextFieldDef, selfContextFieldRef);
                            break;
                        case Code.Call:
                        case Code.Callvirt:
                        case Code.Newobj:
                            HandleMethodCall(inst, enumeratorMethod, arguments, mappedMethods, contextFieldDef, selfContextFieldRef);
                            break;
                    }
                }
            }
        }

        private void HandleMethodCall(Instruction methodCallInstruction, MethodDefinition enumeratorMethod, PatcherArguments arguments, ContextBoundMethodMap mappedMethods, FieldDefinition captureContextField, FieldReference captureContextFieldRef) {
            var calleeRef = (MethodReference)methodCallInstruction.Operand;

            var option = MonoModCommon.Structure.MapOption.Create(true, providers: [(enumeratorMethod.DeclaringType.DeclaringType, enumeratorMethod.DeclaringType)]);
            calleeRef = MonoModCommon.Structure.DeepMapMethodReference(calleeRef, option);
            if (!this.AdjustMethodReferences(arguments, mappedMethods, ref calleeRef, out MethodDefinition? contextBoundMethodDef, out MethodReference? vanillaCallee, out ContextTypeData? contextProvider)) {
                return;
            }

            // Generate context loading instructions
            Instruction[] loadInstanceInsts = BuildContextLoadInstrs(arguments, captureContextField, captureContextFieldRef, contextProvider);
            this.InjectContextParameterLoads(arguments, ref methodCallInstruction, out _, enumeratorMethod, calleeRef, vanillaCallee, contextProvider, loadInstanceInsts);
        }

        void HandleStoreStaticField(Instruction instruction, MethodDefinition generatedMethod, PatcherArguments arguments, FieldDefinition captureContextField, FieldReference captureContextFieldRef) {
            var fieldRef = (FieldReference)instruction.Operand;
            if (!arguments.InstanceConvdFieldOrgiMap.TryGetValue(fieldRef.GetIdentifier(), out FieldDefinition? contextBoundFieldDef)) {
                return;
            }

            ContextTypeData? contextType = null;
            if (contextBoundFieldDef.DeclaringType.FullName != arguments.RootContextDef.FullName) {
                contextType = arguments.ContextTypes[contextBoundFieldDef.DeclaringType.FullName];
            }

            Instruction[] loadInstanceInsts = BuildContextLoadInstrs(arguments, captureContextField, captureContextFieldRef, contextType);
            this.InjectContextFieldStoreInstanceLoads(arguments, ref instruction, out _, generatedMethod, contextBoundFieldDef, fieldRef, loadInstanceInsts);
        }

        void HandleLoadStaticField(Instruction instruction, MethodDefinition generatedMethod, bool isAddress, PatcherArguments arguments, FieldDefinition captureContextField, FieldReference captureContextFieldRef) {
            var fieldRef = (FieldReference)instruction.Operand;
            if (!arguments.InstanceConvdFieldOrgiMap.TryGetValue(fieldRef.GetIdentifier(), out FieldDefinition? contextBoundFieldDef)) {
                return;
            }

            ContextTypeData? contextType = null;
            if (contextBoundFieldDef.DeclaringType.FullName != arguments.RootContextDef.FullName) {
                contextType = arguments.ContextTypes[contextBoundFieldDef.DeclaringType.FullName];
            }

            Instruction[] loadInstanceInsts = BuildContextLoadInstrs(arguments, captureContextField, captureContextFieldRef, contextType);
            this.InjectContextFieldLoadInstanceLoads(arguments, ref instruction, out _, isAddress, generatedMethod, contextBoundFieldDef, fieldRef, loadInstanceInsts);
        }
        /// <summary>
        /// Builds the context load instructions
        /// </summary>
        /// <param name="arguments"></param>
        /// <param name="closureData"></param>
        /// <param name="requestedContextType"></param>
        /// <returns></returns>
        /// <exception cref="Exception"></exception>
        static Instruction[] BuildContextLoadInstrs(PatcherArguments arguments, FieldDefinition captureContextField, FieldReference captureContextFieldRef, ContextTypeData? requestedContextType) {
            List<Instruction> result = [];

            TypeReference closureContextType = captureContextField.FieldType;

            if (requestedContextType is not null && closureContextType.FullName == requestedContextType.ContextTypeDef.FullName) {
                return [
                    Instruction.Create(OpCodes.Ldarg_0),
                    Instruction.Create(OpCodes.Ldfld, captureContextFieldRef)
                ];
            }
            // If context of closure is member of root context
            if (arguments.ContextTypes.TryGetValue(closureContextType.FullName, out ContextTypeData? callerDeclaringInstanceConvdType)) {
                result.Add(Instruction.Create(OpCodes.Ldarg_0));
                result.Add(Instruction.Create(OpCodes.Ldfld, captureContextFieldRef));
                result.Add(Instruction.Create(OpCodes.Ldfld, callerDeclaringInstanceConvdType.rootContextField));
            }
            // elsewise, context of closure must be the root context
            else if (closureContextType.FullName == arguments.RootContextDef.FullName) {
                result.Add(Instruction.Create(OpCodes.Ldarg_0));
                result.Add(Instruction.Create(OpCodes.Ldfld, captureContextFieldRef));
            }
            else {
                throw new Exception($"Unexpected closure context type {closureContextType.FullName}");
            }

            if (requestedContextType is not null) {
                foreach (FieldDefinition field in requestedContextType.nestedChain) {
                    result.Add(Instruction.Create(OpCodes.Ldfld, field));
                }
            }

            return [.. result];
        }
    }
}
