using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Rocks;
using OTAPI.UnifiedServerProcess.Commons;
using OTAPI.UnifiedServerProcess.Core.Analysis.MethodCallAnalysis;
using OTAPI.UnifiedServerProcess.Core.FunctionalFeatures;
using OTAPI.UnifiedServerProcess.Core.Patching.DataModels;
using OTAPI.UnifiedServerProcess.Core.Patching.GeneralPatching.Arguments;
using OTAPI.UnifiedServerProcess.Extensions;
using OTAPI.UnifiedServerProcess.Loggers;
using System;
using System.Collections.Generic;
using System.Linq;

namespace OTAPI.UnifiedServerProcess.Core.Patching.GeneralPatching
{
    /// <summary>
    /// Handle the contextualization of the iterator generated by yield return
    /// </summary>
    /// <param name="logger"></param>
    /// <param name="methodCallGraph"></param>
    public sealed class EnumeratorCtxAdaptPatcher(ILogger logger, MethodCallGraph methodCallGraph) : GeneralPatcher(logger), IContextInjectFeature, IMethodCheckCacheFeature
    {
        public sealed override string Name => nameof(EnumeratorCtxAdaptPatcher);
        public MethodCallGraph MethodCallGraph => methodCallGraph;

        public sealed override void Patch(PatcherArguments arguments) {
            var module = arguments.MainModule;
            var mappedMethod = arguments.LoadVariable<ContextBoundMethodMap>();

            Dictionary<string, MethodDefinition> addedParamMethods = [];

            foreach (var type in module.GetAllTypes().ToArray()) {

                foreach (var method in type.Methods.ToArray()) {
                    if (!method.HasBody) {
                        continue;
                    }
                    var methodId = method.GetIdentifier();
                    // Only context bound methods could process,
                    if (mappedMethod.originalToContextBound.ContainsKey(methodId)) {
                        // And only reused singleton methods could be context bound at same time existing in the original method map
                        if (!arguments.ContextTypes.TryGetValue(type.FullName, out var singletonType)
                            || !singletonType.IsReusedSingleton
                            || !singletonType.ReusedSingletonMethods.ContainsKey(methodId)) {
                            continue;
                        }
                    }
                    ProcessMethod(arguments, mappedMethod, method);
                }
            }
        }

        void ProcessMethod(PatcherArguments arguments,
            ContextBoundMethodMap mappedMethod,
            MethodDefinition caller) {

            Dictionary<string, (TypeReference enumeratorRef, FieldReference contextFieldRef)> processedEnumerator = [];
            foreach (var instruction in caller.Body.Instructions.ToArray()) {
                if (instruction.OpCode != OpCodes.Newobj) {
                    continue;
                }
                var ctor = (MethodReference)instruction.Operand;
                if (!ctor.DeclaringType.Name.OrdinalStartsWith('<')) {
                    continue;
                }
                var enumeratorDef = ctor.DeclaringType.Resolve();
                if (enumeratorDef is null) {
                    continue;
                }
                if (!enumeratorDef.Interfaces.Any(x => x.InterfaceType.FullName == "System.Collections.IEnumerator")) {
                    continue;
                }
                bool anyContextUsed = false;
                foreach (var method in enumeratorDef.Methods) {
                    if (method.IsConstructor) {
                        continue;
                    }
                    if (this.CheckUsedContextBoundField(arguments.InstanceConvdFieldOrgiMap, method)) {
                        anyContextUsed = true;
                        break;
                    }
                }
                if (!anyContextUsed) {
                    continue;
                }

                if (caller.DeclaringType.FullName != enumeratorDef.DeclaringType.FullName) {
                    var option = new MonoModCommon.Structure.MapOption(typeReplace: new() { { enumeratorDef.DeclaringType, caller.DeclaringType } });
                    var oldEnumeratorDef = enumeratorDef;
                    enumeratorDef = PatchingCommon.MemberClonedType(enumeratorDef, enumeratorDef.Name, option.TypeReplaceMap);

                    foreach (var redirectInst in caller.Body.Instructions) {
                        if (redirectInst.Operand is TypeReference typeRef) {
                            redirectInst.Operand = MonoModCommon.Structure.DeepMapTypeReference(typeRef, option);
                        }
                        else if (redirectInst.Operand is MethodReference methodRef) {
                            redirectInst.Operand = MonoModCommon.Structure.DeepMapMethodReference(methodRef, option);
                        }
                        else if (redirectInst.Operand is FieldReference fieldRef) {
                            var fieldDef = fieldRef.Resolve();
                            if (fieldDef is null) {
                                continue;
                            }
                            var declaringType = fieldRef.DeclaringType;
                            if (option.TypeReplaceMap.TryGetValue(declaringType.Resolve(), out var mappedDeclaringType)
                                && mappedDeclaringType.Fields.Any(f => f.Name == fieldDef.Name && f.IsStatic == fieldDef.IsStatic)) {
                                declaringType = MonoModCommon.Structure.DeepMapTypeReference(fieldRef.DeclaringType, option);
                            }
                            redirectInst.Operand = new FieldReference(fieldRef.Name,
                                MonoModCommon.Structure.DeepMapTypeReference(fieldRef.FieldType, option),
                                declaringType);
                        }
                    }
                }

                FieldDefinition contextFieldDef;
                ParameterDefinition captureParameter;

                if (arguments.ContextTypes.TryGetValue(caller.DeclaringType.FullName, out var contextBoundType)) {
                    contextFieldDef = new FieldDefinition("<>4__this", FieldAttributes.Public, contextBoundType.ContextTypeDef);
                    enumeratorDef.Fields.Add(contextFieldDef);
                    captureParameter = caller.Body.ThisParameter;
                }
                else if (caller.Parameters[0].ParameterType.FullName == arguments.RootContextDef.FullName) {
                    contextFieldDef = new FieldDefinition(caller.Parameters[0].Name, FieldAttributes.Public, arguments.RootContextDef);
                    enumeratorDef.Fields.Add(contextFieldDef);
                    captureParameter = caller.Parameters[0];
                }
                else {
                    throw new Exception($"Unexpected caller {caller.GetDebugName()} without context bound");
                }

                TypeReference enumeratorRef;
                FieldReference contextFieldRef;
                if (!processedEnumerator.TryGetValue(enumeratorDef.FullName, out var enumeratorInfo)) {
                    enumeratorRef = enumeratorDef;
                    contextFieldRef = contextFieldDef;
                    if (enumeratorDef.DeclaringType.HasGenericParameters) {
                        var enumeratorGenericRef = new GenericInstanceType(enumeratorDef);
                        foreach (var genericParam in enumeratorDef.DeclaringType.GenericParameters) {
                            enumeratorGenericRef.GenericArguments.Add(genericParam);
                        }
                        enumeratorRef = enumeratorGenericRef;
                        contextFieldRef = new FieldReference(contextFieldDef.Name, contextFieldDef.FieldType, enumeratorRef);
                    }
                    enumeratorInfo = (enumeratorRef, contextFieldRef);
                }
                else {
                    enumeratorRef = enumeratorInfo.enumeratorRef;
                    contextFieldRef = enumeratorInfo.contextFieldRef;
                }

                var afterCreateEnumerator = caller.Body.Instructions.Single(
                    x =>
                    x.OpCode == OpCodes.Newobj && ((MethodReference)x.Operand).DeclaringType.TryResolve()?.FullName == enumeratorDef.FullName)
                    .Next;
                var ilProcessor = caller.Body.GetILProcessor();
                ilProcessor.InsertBeforeSeamlessly(ref afterCreateEnumerator, [
                    Instruction.Create(OpCodes.Dup),
                    MonoModCommon.IL.BuildParameterLoad(caller, caller.Body, captureParameter),
                    Instruction.Create(OpCodes.Stfld, contextFieldRef)
                ]);

                ProcessEnumeratorMethod(arguments, mappedMethod, enumeratorDef, contextFieldDef, caller);
            }
        }

        private void ProcessEnumeratorMethod(
            PatcherArguments arguments,
            ContextBoundMethodMap mappedMethods,
            TypeDefinition enumeratorDef,
            FieldDefinition contextFieldDef,
            MethodDefinition caller) {

            TypeReference selfEnumeratorRef = enumeratorDef;
            FieldReference selfContextFieldRef = contextFieldDef;
            if (enumeratorDef.HasGenericParameters) {
                var selfEnumeratorGenericRef = new GenericInstanceType(enumeratorDef);
                foreach (var genericParam in enumeratorDef.GenericParameters) {
                    selfEnumeratorGenericRef.GenericArguments.Add(genericParam);
                }
                selfEnumeratorRef = selfEnumeratorGenericRef;
                selfContextFieldRef = new FieldReference(contextFieldDef.Name, contextFieldDef.FieldType, selfEnumeratorRef);
            }

            foreach (var enumeratorMethod in enumeratorDef.Methods) {
                if (enumeratorMethod.IsConstructor) {
                    continue;
                }
                foreach (var inst in enumeratorMethod.Body.Instructions.ToArray()) {
                    switch (inst.OpCode.Code) {
                        case Code.Ldsfld:
                            HandleLoadStaticField(inst, enumeratorMethod, false, arguments, contextFieldDef, selfContextFieldRef);
                            break;
                        case Code.Ldsflda:
                            HandleLoadStaticField(inst, enumeratorMethod, true, arguments, contextFieldDef, selfContextFieldRef);
                            break;
                        case Code.Stsfld:
                            HandleStoreStaticField(inst, enumeratorMethod, arguments, contextFieldDef, selfContextFieldRef);
                            break;
                        case Code.Call:
                        case Code.Callvirt:
                        case Code.Newobj:
                            HandleMethodCall(inst, enumeratorMethod, arguments, mappedMethods, contextFieldDef, selfContextFieldRef);
                            break;
                    }
                }
            }
        }

        private void HandleMethodCall(Instruction methodCallInstruction, MethodDefinition enumeratorMethod, PatcherArguments arguments, ContextBoundMethodMap mappedMethods, FieldDefinition captureContextField, FieldReference captureContextFieldRef) {
            var calleeRef = (MethodReference)methodCallInstruction.Operand;

            var option = MonoModCommon.Structure.MapOption.Create(providers: [(enumeratorMethod.DeclaringType.DeclaringType, enumeratorMethod.DeclaringType)]);
            calleeRef = MonoModCommon.Structure.DeepMapMethodReference(calleeRef, option);
            if (!this.AdjustMethodReferences(arguments, mappedMethods, ref calleeRef, out var contextBoundMethodDef, out var vanillaCallee, out var contextProvider)) {
                return;
            }

            // Generate context loading instructions
            var loadInstanceInsts = BuildContextLoadInstrs(arguments, captureContextField, captureContextFieldRef, contextProvider);
            this.InjectContextParameterLoads(arguments, ref methodCallInstruction, out _, enumeratorMethod, contextBoundMethodDef, calleeRef, vanillaCallee, contextProvider, loadInstanceInsts);
        }

        void HandleStoreStaticField(Instruction instruction, MethodDefinition generatedMethod, PatcherArguments arguments, FieldDefinition captureContextField, FieldReference captureContextFieldRef) {
            var fieldRef = (FieldReference)instruction.Operand;
            if (!arguments.InstanceConvdFieldOrgiMap.TryGetValue(fieldRef.GetIdentifier(), out var contextBoundFieldDef)) {
                return;
            }

            ContextTypeData? contextType = null;
            if (contextBoundFieldDef.DeclaringType.FullName != arguments.RootContextDef.FullName) {
                contextType = arguments.ContextTypes[contextBoundFieldDef.DeclaringType.FullName];
            }

            var loadInstanceInsts = BuildContextLoadInstrs(arguments, captureContextField, captureContextFieldRef, contextType);
            this.InjectContextFieldStoreInstanceLoads(arguments, ref instruction, out _, generatedMethod, contextBoundFieldDef, fieldRef, loadInstanceInsts);
        }

        void HandleLoadStaticField(Instruction instruction, MethodDefinition generatedMethod, bool isAddress, PatcherArguments arguments, FieldDefinition captureContextField, FieldReference captureContextFieldRef) {
            var fieldRef = (FieldReference)instruction.Operand;
            if (!arguments.InstanceConvdFieldOrgiMap.TryGetValue(fieldRef.GetIdentifier(), out var contextBoundFieldDef)) {
                return;
            }

            ContextTypeData? contextType = null;
            if (contextBoundFieldDef.DeclaringType.FullName != arguments.RootContextDef.FullName) {
                contextType = arguments.ContextTypes[contextBoundFieldDef.DeclaringType.FullName];
            }

            var loadInstanceInsts = BuildContextLoadInstrs(arguments, captureContextField, captureContextFieldRef, contextType);
            this.InjectContextFieldLoadInstanceLoads(arguments, ref instruction, out _, isAddress, generatedMethod, contextBoundFieldDef, fieldRef, loadInstanceInsts);
        }
        /// <summary>
        /// Builds the context load instructions
        /// </summary>
        /// <param name="arguments"></param>
        /// <param name="closureData"></param>
        /// <param name="requestedContextType"></param>
        /// <returns></returns>
        /// <exception cref="Exception"></exception>
        static Instruction[] BuildContextLoadInstrs(PatcherArguments arguments, FieldDefinition captureContextField, FieldReference captureContextFieldRef, ContextTypeData? requestedContextType) {
            List<Instruction> result = [];

            var closureContextType = captureContextField.FieldType;

            if (requestedContextType is not null && closureContextType.FullName == requestedContextType.ContextTypeDef.FullName) {
                return [
                    Instruction.Create(OpCodes.Ldarg_0),
                    Instruction.Create(OpCodes.Ldfld, captureContextFieldRef)
                ];
            }
            // If context of closure is member of root context
            if (arguments.ContextTypes.TryGetValue(closureContextType.FullName, out var callerDeclaringInstanceConvdType)) {
                result.Add(Instruction.Create(OpCodes.Ldarg_0));
                result.Add(Instruction.Create(OpCodes.Ldfld, captureContextFieldRef));
                result.Add(Instruction.Create(OpCodes.Ldfld, callerDeclaringInstanceConvdType.rootContextField));
            }
            // elsewise, context of closure must be the root context
            else if (closureContextType.FullName == arguments.RootContextDef.FullName) {
                result.Add(Instruction.Create(OpCodes.Ldarg_0));
                result.Add(Instruction.Create(OpCodes.Ldfld, captureContextFieldRef));
            }
            else {
                throw new Exception($"Unexpected closure context type {closureContextType.FullName}");
            }

            if (requestedContextType is not null) {
                foreach (var field in requestedContextType.nestedChain) {
                    result.Add(Instruction.Create(OpCodes.Ldfld, field));
                }
            }

            return [.. result];
        }
    }
}
